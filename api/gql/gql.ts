/* eslint-disable */
import * as types from './graphql'
import type { TypedDocumentNode as DocumentNode } from '@graphql-typed-document-node/core'

/**
 * Map of all GraphQL operations in the project.
 *
 * This map has several performance disadvantages:
 * 1. It is not tree-shakeable, so it will include all operations in the project.
 * 2. It is not minifiable, so the string of a GraphQL query will be multiple times inside the bundle.
 * 3. It does not support dead code elimination, so it will add unused operations.
 *
 * Therefore it is highly recommended to use the babel or swc plugin for production.
 */
const documents = {
  '\n  mutation EditAccountName($account: String!, $name: String!, $network: String!) {\n      changeAccountName(\n          arg: {\n              account: $account\n              name: $name\n              network: $network\n          }\n      ) {\n          status\n      }}':
    types.EditAccountNameDocument,
  '\n  query GetAccountName($address: String!, $network: String!) {\n    account: user_account(where: { _and: { address: { _eq: $address }, network: { _ilike: $network } } }) {\n      name\n    }\n  }\n':
    types.GetAccountNameDocument,
  '\nquery getAgentsBageData {\n    activeAgents: agent_aggregate(\n      where: { _and: { banned: { _neq: true }, paused: { _neq: true } } }\n    ) {\n      aggregate {\n        count\n      }\n    }\n    allAgents: agent_aggregate {\n      aggregate {\n        count\n      }\n    }\n    totalMessages: operations_aggregate {\n      aggregate {\n        count\n      }\n    }\n    totalDelegation: agent_info_delegator_aggregate {\n      aggregate {\n        sum {\n          stake\n        }\n      }\n    }\n    supportedChains: protocol_executor_aggregate(distinct_on: chain_id) {\n      aggregate {\n        count\n      }\n    }\n    inflightMessages: operations_aggregate(\n      where: { is_inflight: { is_inflight: { _eq: true } } }\n    ) {\n      aggregate {\n        count\n      }\n    }\n    confirmedMessages: operation_count_agent_address_aggregate {\n      aggregate {\n        sum {\n          msg_count\n        }\n      }\n    }\n  }\n':
    types.GetAgentsBageDataDocument,
  '\n  query getAgentsByFilters(\n    $where: agent_bool_exp = {}\n    $order_by: [agent_order_by!] = {}\n    $limit: Int\n    $offset: Int\n    $delegatorAddress: String = ""\n  ) {\n    agent(where: $where, order_by: $order_by, offset: $offset, limit: $limit) {\n      agent_protocol_supports {\n        protocol_id\n        id\n        created_at\n        agent_address\n        removed\n        transmitter\n        success_message_count {\n          msg_count\n        }\n        protocol {\n          id\n          protocol_id\n          protocol_executors {\n            chain_id\n          }\n        }\n      }\n      id\n      agent_address\n      operations_count {\n        msg_count\n      }\n      operation_count_total {\n        msg_count\n      }\n      agentInfoData: agent_info {\n        active_round_stake\n        address\n        personal_stake\n        relatime_stake\n        id\n        fee\n        unclaimed_rewards\n        deligatedSum: agent_info_delegators_aggregate {\n          aggregate {\n            sum {\n              stake\n            }\n          }\n        }\n        currentDelegated: agent_info_delegators (where: {address: {_eq: $delegatorAddress }}) {\n          id\n          stake\n          address\n      }\n      }\n      banned\n      created_at\n      paused\n      reward_address\n      agent_name {\n        name\n      }\n    }\n  }\n':
    types.GetAgentsByFiltersDocument,
  '\n  query getAgentsByAddressAndAgentAddress(\n    $address: String\n    $agentAddress: String\n  ) {\n    agent_info_delegator(\n      where: {\n        _and: { address: { _eq: $address } }\n        agent_info: { address: { _eq: $agentAddress } }\n      }\n    ) {\n      id\n      stake\n      unclaimed_rewards\n    }\n  }\n':
    types.GetAgentsByAddressAndAgentAddressDocument,
  'query getAgentsDelegatedAmount($delegatorAddress: String = "") {\n    agent_info_delegator_aggregate(where: {address: {_eq: $delegatorAddress}}) {\n      aggregate {\n        sum {\n          stake\n        }\n      }\n    }\n}':
    types.GetAgentsDelegatedAmountDocument,
  '\nquery getAgentsByAddress($address: String = "", $order_by: [agent_order_by!] = {}, $limit: Int, $offset: Int) {\n  agent(where: {agent_info: {agent_info_delegators: {address: {_eq: $address}}}}, order_by: $order_by, offset: $offset, limit: $limit) {\n    agent_protocol_supports {\n      protocol_id\n      id\n      created_at\n      agent_address\n      removed\n      transmitter\n      success_message_count {\n        msg_count\n      }\n      protocol {\n        id\n        protocol_id\n        protocol_executors {\n          chain_id\n        }\n      }\n    }\n    id\n    agent_address\n    operations_count {\n      msg_count\n    }\n    operation_count_total {\n      msg_count\n    }\n    agentInfoData: agent_info {\n      active_round_stake\n      address\n      personal_stake\n      relatime_stake\n      id\n      fee\n      deligatedSum: agent_info_delegators_aggregate {\n        aggregate {\n          sum {\n            stake\n          }\n        }\n      }\n      currentDelegated: agent_info_delegators (where: {address: {_eq: $address }}) {\n        id\n        stake\n        address\n      }\n    }\n    banned\n    created_at\n    paused\n    reward_address\n    agent_name {\n        name\n    }\n  }\n}\n':
    types.GetAgentsByAddressDocument,
  '\n  query GetFrontendConfig($id: Int!) {\n    frontend_configs_by_pk(id: $id) {\n      id\n      config\n    }\n  }\n':
    types.GetFrontendConfigDocument,
  '\n  query AverageBlockTime {\n    averageBlockTime: average_block_time_per_hour(limit: 1, order_by: { height: desc }) {\n      averageTime: average_time\n    }\n  }\n':
    types.AverageBlockTimeDocument,
  '\n  query LatestBlockHeightListener($offset: Int = 0) {\n    height: block(order_by: { height: desc }, limit: 1, offset: $offset) {\n      height\n    }\n  }\n':
    types.LatestBlockHeightListenerDocument,
  '\n  query Blocks($limit: Int = 50, $offset: Int = 0, $where: block_bool_exp = {}) {\n    blocks: block(limit: $limit, offset: $offset, order_by: { height: desc }, where: $where) {\n      height\n      txs: num_txs\n      hash\n      timestamp\n      validator {\n        validatorInfo: validator_info {\n          operatorAddress: operator_address\n          self_delegate_address\n        }\n        validatorDescriptions: validator_descriptions(limit: 1, order_by: { height: desc }) {\n          moniker\n          identity\n        }\n      }\n    }\n  }\n':
    types.BlocksDocument,
  '\n  subscription BlocksListener(\n    $limit: Int = 50\n    $offset: Int = 0\n    $where: block_bool_exp = {}\n  ) {\n    blocks: block(limit: $limit, offset: $offset, order_by: { height: desc }, where: $where) {\n      height\n      txs: num_txs\n      hash\n      timestamp\n      validator {\n        validatorInfo: validator_info {\n          operatorAddress: operator_address\n          self_delegate_address\n        }\n        validatorDescriptions: validator_descriptions(limit: 1, order_by: { height: desc }) {\n          moniker\n          identity\n        }\n      }\n    }\n  }\n':
    types.BlocksListenerDocument,
  '\n  query GetTransactionsPerBlock($limit: Int, $offset: Int, $hash: String) {\n    block(where: { hash: { _eq: $hash } }) {\n      timestamp\n      transactions {\n        height\n        hash\n        memo\n        success\n        fee\n        gasUsed: gas_used\n        gasWanted: gas_wanted\n        messages\n        logs\n        __typename\n      }\n    }\n  }\n':
    types.GetTransactionsPerBlockDocument,
  '\n  query GetBlocksByHash($hash: String) {\n    blocks: block(where: { hash: { _eq: $hash } }) {\n      height\n      txs: num_txs\n      hash\n      timestamp\n      validator {\n        validatorInfo: validator_info {\n          operatorAddress: operator_address\n          self_delegate_address\n        }\n        validatorDescriptions: validator_descriptions(limit: 1, order_by: { height: desc }) {\n          moniker\n          identity\n        }\n      }\n    }\n  }\n':
    types.GetBlocksByHashDocument,
  '\n  query GetTransactionStatus(\n    $txHash: String!\n    $destChainId: numeric!\n    $sourceChainId: numeric!\n  ) {\n    bridge(\n      arg1: { dst_chain_id: $destChainId, src_chain_id: $sourceChainId, tx_hash: $txHash }\n    ) {\n      address_from\n      created_at\n      failed\n      id\n      operation_one_hash\n      operation_one_tx_hash\n      operation_two_hash\n      operation_two_tx_hash\n      src_hash\n      step\n      updated_at\n    }\n  }\n':
    types.GetTransactionStatusDocument,
  '\n  subscription BridgeOperationsListener($address:String!) {\n    common_bridge_operations(\n      where: {\n        _or: [\n          { sender: { _eq: $address } },\n          { recipient: { _eq: $address } },\n          { metadata: { _contains: { additional_account: $address } } }\n        ]\n      }\n      order_by: { created_at: desc }\n    ) {\n      amount\n      arrived_at\n      bridge_protocol\n      created_at\n      dst_chain_id\n      dst_tx_hash\n      metadata\n      id\n      sender\n      src_chain_id\n      src_tx_hash\n      status\n      token\n      updated_at\n      recipient\n    }\n  }\n':
    types.BridgeOperationsListenerDocument,
  '\nquery GetBridgeOperationsByTxHas($address:String!) {\n    common_bridge_operations(\n      where: { src_tx_hash: { _eq: $address } }\n      order_by: { created_at: desc }\n    ) {\n      amount\n      arrived_at\n      bridge_protocol\n      created_at\n      dst_chain_id\n      dst_tx_hash\n      metadata\n      id\n      sender\n      src_chain_id\n      src_tx_hash\n      status\n      token\n      updated_at\n      recipient\n    }\n}':
    types.GetBridgeOperationsByTxHasDocument,
  '\nquery GetBridgeOperationsBySender($address:String!) {\n    common_bridge_operations(\n        where: {\n            sender: { _eq: $address }\n        }\n    ) {\n      amount\n      arrived_at\n      bridge_protocol\n      created_at\n      dst_chain_id\n      dst_tx_hash\n      metadata\n      id\n      sender\n      src_chain_id\n      src_tx_hash\n      status\n      token\n      updated_at\n      recipient\n    }\n}':
    types.GetBridgeOperationsBySenderDocument,
  '\n  query GetBridgeOperationsCount($address:String!) {\n    common_bridge_operations_aggregate(where: { sender:{_eq:$address}}) {\n      aggregate {\n        count\n      }\n    }\n  }\n':
    types.GetBridgeOperationsCountDocument,
  '\n  query GetOperationsByFilters(\n    $where: operations_bool_exp = { _and: {} }\n    $limit: Int\n    $offset: Int\n  ) {\n    operations(\n      where: $where\n      offset: $offset\n      limit: $limit\n      order_by: { created_at: desc }\n    ) {\n      src_tx_sender\n      src_tx_hash\n      src_chain_id\n      src_block_number\n      required_confirmations\n      protocol_id\n      protocol_address\n      params\n      nonce\n      in_order\n      id\n      hash\n      function_selector\n      dst_chain_id\n      destination_tx_hash\n      delivered\n      created_at\n      operation_proof {\n        operation_proof_transmitter_sigs_aggregate {\n          aggregate {\n            count\n          }\n        }\n      }\n    }\n  }\n':
    types.GetOperationsByFiltersDocument,
  '\n  subscription MessagesListener(\n    $where: operations_bool_exp = { _and: {} }\n    $limit: Int\n    $offset: Int\n  ) {\n    operations(where: $where, offset: $offset, limit: $limit, order_by: { created_at: desc }) {\n      src_tx_sender\n      src_tx_hash\n      src_chain_id\n      src_block_number\n      required_confirmations\n      protocol_id\n      protocol_address\n      params\n      nonce\n      in_order\n      id\n      hash\n      function_selector\n      dst_chain_id\n      destination_tx_hash\n      delivered\n      created_at\n      operation_proof {\n        operation_proof_transmitter_sigs_aggregate {\n          aggregate {\n            count\n          }\n        }\n      }\n    }\n  }\n':
    types.MessagesListenerDocument,
  '\n  query Params {\n    staking_params {\n      params\n    }\n\n    slashing_params {\n      params\n    }\n\n    gov_params {\n      params\n    }\n\n    distribution_params {\n      params\n    }\n  }\n':
    types.ParamsDocument,
  '\n  query GetProtocolsByFilters(\n    $where: protocol_bool_exp = { _and: {} }\n    $order_by: [protocol_order_by!] = {}\n    $limit: Int\n    $offset: Int\n  ) {\n    protocol(where: $where, order_by: $order_by, offset: $offset, limit: $limit) {\n      consensus_target_rate\n      created_at\n      data_bet_amount\n      data_bet_reward\n      first_data_bet_reward\n      first_msg_bet_reward\n      id\n      max_transmitters\n      min_delegate_amount\n      min_personal_amount\n      msg_bet_amount\n      msg_bet_reward\n      owner\n      protocol_id\n      operations_count {\n        count\n      }\n      protocol_transmitters {\n        transmitter\n      }\n      protocol_executors {\n        chain_id\n      }\n      protocol_transmitters_aggregate {\n        aggregate {\n          count(columns: id)\n        }\n      }\n    }\n  }\n':
    types.GetProtocolsByFiltersDocument,
  '\n  query getProtocolById($id: String) {\n    protocol(where: { protocol_id: { _eq: $id } }) {\n      operations(limit: 1, order_by: { created_at: desc }) {\n        required_confirmations\n      }\n      consensus_target_rate\n      created_at\n      data_bet_amount\n      data_bet_reward\n      balance\n      first_data_bet_reward\n      first_msg_bet_reward\n      id\n      protocol_proposers {\n        chain_id\n      }\n      max_transmitters\n      min_delegate_amount\n      min_personal_amount\n      msg_bet_amount\n      msg_bet_reward\n      owner\n      protocol_id\n      operations_count {\n        count\n      }\n      protocol_transmitters {\n        transmitter\n      }\n      protocol_executors {\n        chain_id\n      }\n      protocol_transmitters_aggregate {\n        aggregate {\n          count(columns: id)\n        }\n      }\n      protocol_proposers_aggregate {\n        aggregate {\n          count\n        }\n      }\n      protocol_executors_aggregate {\n        aggregate {\n          count\n        }\n      }\n    }\n  }\n':
    types.GetProtocolByIdDocument,
  '\n  query Tokenomics {\n    stakingParams: staking_params(limit: 1) {\n      params\n    }\n    stakingPool: staking_pool(order_by: { height: desc }, limit: 1) {\n      bonded: bonded_tokens\n      unbonded: not_bonded_tokens\n    }\n    supply: supply(order_by: { height: desc }, limit: 1) {\n      coins\n    }\n  }\n':
    types.TokenomicsDocument,
  '\n  query Transactions($limit: Int, $offset: Int, $where: transaction_bool_exp = {}) {\n    transactions: transaction(\n      limit: $limit\n      offset: $offset\n      order_by: { height: desc }\n      where: $where\n    ) {\n      height\n      hash\n      memo\n      success\n      fee\n      gasUsed: gas_used\n      gasWanted: gas_wanted\n      block {\n        timestamp\n        __typename\n      }\n      messages\n      logs\n      __typename\n    }\n  }\n':
    types.TransactionsDocument,
  '\n  query Transaction($ethHash: String) {\n    transaction(where: { eth_hash: { _eq: $ethHash } }) {\n      height\n      hash\n      memo\n      success\n      fee\n      gasUsed: gas_used\n      gasWanted: gas_wanted\n      block {\n        timestamp\n        __typename\n      }\n      messages\n      logs\n      __typename\n    }\n  }\n':
    types.TransactionDocument,
  '\n  subscription TransactionsListener(\n    $limit: Int = 7\n    $offset: Int = 0\n    $where: transaction_bool_exp = {}\n  ) {\n    transactions: transaction(\n      limit: $limit\n      offset: $offset\n      order_by: { height: desc }\n      where: $where\n    ) {\n      height\n      hash\n      memo\n      success\n      fee\n      gasUsed: gas_used\n      gasWanted: gas_wanted\n      block {\n        timestamp\n        __typename\n      }\n      messages\n      logs\n      __typename\n    }\n  }\n':
    types.TransactionsListenerDocument,
  '\n  subscription priceChartsSubscription ($where: price_charts_bool_exp = {}) {\n    price_charts(where: $where) {\n      asset_id\n      category_id\n      chart\n      data_key\n      time\n      value\n      assets_info {\n        icon_url\n        category {\n          name\n        }\n        float_digits\n        decimals\n      }\n    }\n  }\n':
    types.PriceChartsSubscriptionDocument,
  '\n  query MarketCategories {\n  category {\n    id\n    name\n  }\n}\n':
    types.MarketCategoriesDocument,
  '\n  query MarketUsdRate {\n  usd_rate {\n    rate\n    currency\n  }\n}\n':
    types.MarketUsdRateDocument,
  '\n  query TotalValueSecured {\n    total_value_secured(limit: 1, order_by: {time:desc}) {\n      value\n    }\n  }\n':
    types.TotalValueSecuredDocument,
  '\n  query ActiveValidatorCount {\n    activeTotal: validator_status_aggregate(where: { status: { _eq: 3 } }) {\n      aggregate {\n        count\n      }\n    }\n    inactiveTotal: validator_status_aggregate(where: { status: { _neq: 3 } }) {\n      aggregate {\n        count\n      }\n    }\n    total: validator_status_aggregate {\n      aggregate {\n        count\n      }\n    }\n  }\n':
    types.ActiveValidatorCountDocument,
  '\n  query getValidators($where: validator_bool_exp = {}) {\n    stakingPool: staking_pool(limit: 1, order_by: { height: desc }) {\n      bondedTokens: bonded_tokens\n    }\n    validator(where: $where, order_by: { real_voting_power: { voting_power: desc } }) {\n      validatorStatuses: validator_statuses(order_by: { height: desc }, limit: 1) {\n        status\n        jailed\n        height\n      }\n      validatorDescriptions: validator_descriptions {\n        moniker\n        avatar_url\n      }\n      validatorSigningInfos: validator_signing_infos(order_by: { height: desc }, limit: 1) {\n        missedBlocksCounter: missed_blocks_counter\n        tombstoned\n        startHeight: start_height\n      }\n      validatorInfo: validator_info {\n        operatorAddress: operator_address\n        selfDelegateAddress: self_delegate_address\n      }\n      validatorVotingPowers: validator_voting_powers(\n        offset: 0\n        limit: 1\n        order_by: { height: desc }\n      ) {\n        votingPower: voting_power\n      }\n      validatorCommissions: validator_commissions(order_by: { height: desc }, limit: 1) {\n        commission\n      }\n      validatorSigningInfos: validator_signing_infos(order_by: { height: desc }, limit: 1) {\n        missedBlocksCounter: missed_blocks_counter\n      }\n      validatorDelegations: validator_delegations {\n        total_delegations\n        self_delegation\n      }\n    }\n    slashingParams: slashing_params(order_by: { height: desc }, limit: 1) {\n      params\n    }\n    validatorStats: validator_stats {\n      apr\n      validator {\n        validator_info {\n          operator_address\n        }\n      }\n    }\n  }\n':
    types.GetValidatorsDocument,
  '\n  query GetValidatorByOperatorAddress($operatorAddress: String!) {\n    validatorInfo: validator_info(where: { operator_address: { _eq: $operatorAddress } }) {\n      validator {\n        validatorStatuses: validator_statuses(order_by: { height: desc }, limit: 1) {\n          status\n          jailed\n          height\n        }\n        validatorDescriptions: validator_descriptions {\n          moniker\n          avatar_url\n        }\n        validatorSigningInfos: validator_signing_infos(order_by: { height: desc }, limit: 1) {\n          missedBlocksCounter: missed_blocks_counter\n          tombstoned\n        }\n        validatorInfo: validator_info {\n          operatorAddress: operator_address\n          selfDelegateAddress: self_delegate_address\n        }\n        validatorVotingPowers: validator_voting_powers(\n          offset: 0\n          limit: 1\n          order_by: { height: desc }\n        ) {\n          votingPower: voting_power\n        }\n        validatorCommissions: validator_commissions(order_by: { height: desc }, limit: 1) {\n          commission\n        }\n        validatorSigningInfos: validator_signing_infos(order_by: { height: desc }, limit: 1) {\n          missedBlocksCounter: missed_blocks_counter\n        }\n      }\n    }\n  }\n':
    types.GetValidatorByOperatorAddressDocument,
}

/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 *
 *
 * @example
 * ```ts
 * const query = gql(`query GetUser($id: ID!) { user(id: $id) { name } }`);
 * ```
 *
 * The query argument is unknown!
 * Please regenerate the types.
 */
export function gql(source: string): unknown

/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(
  source: '\n  mutation EditAccountName($account: String!, $name: String!, $network: String!) {\n      changeAccountName(\n          arg: {\n              account: $account\n              name: $name\n              network: $network\n          }\n      ) {\n          status\n      }}'
): (typeof documents)['\n  mutation EditAccountName($account: String!, $name: String!, $network: String!) {\n      changeAccountName(\n          arg: {\n              account: $account\n              name: $name\n              network: $network\n          }\n      ) {\n          status\n      }}']
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(
  source: '\n  query GetAccountName($address: String!, $network: String!) {\n    account: user_account(where: { _and: { address: { _eq: $address }, network: { _ilike: $network } } }) {\n      name\n    }\n  }\n'
): (typeof documents)['\n  query GetAccountName($address: String!, $network: String!) {\n    account: user_account(where: { _and: { address: { _eq: $address }, network: { _ilike: $network } } }) {\n      name\n    }\n  }\n']
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(
  source: '\nquery getAgentsBageData {\n    activeAgents: agent_aggregate(\n      where: { _and: { banned: { _neq: true }, paused: { _neq: true } } }\n    ) {\n      aggregate {\n        count\n      }\n    }\n    allAgents: agent_aggregate {\n      aggregate {\n        count\n      }\n    }\n    totalMessages: operations_aggregate {\n      aggregate {\n        count\n      }\n    }\n    totalDelegation: agent_info_delegator_aggregate {\n      aggregate {\n        sum {\n          stake\n        }\n      }\n    }\n    supportedChains: protocol_executor_aggregate(distinct_on: chain_id) {\n      aggregate {\n        count\n      }\n    }\n    inflightMessages: operations_aggregate(\n      where: { is_inflight: { is_inflight: { _eq: true } } }\n    ) {\n      aggregate {\n        count\n      }\n    }\n    confirmedMessages: operation_count_agent_address_aggregate {\n      aggregate {\n        sum {\n          msg_count\n        }\n      }\n    }\n  }\n'
): (typeof documents)['\nquery getAgentsBageData {\n    activeAgents: agent_aggregate(\n      where: { _and: { banned: { _neq: true }, paused: { _neq: true } } }\n    ) {\n      aggregate {\n        count\n      }\n    }\n    allAgents: agent_aggregate {\n      aggregate {\n        count\n      }\n    }\n    totalMessages: operations_aggregate {\n      aggregate {\n        count\n      }\n    }\n    totalDelegation: agent_info_delegator_aggregate {\n      aggregate {\n        sum {\n          stake\n        }\n      }\n    }\n    supportedChains: protocol_executor_aggregate(distinct_on: chain_id) {\n      aggregate {\n        count\n      }\n    }\n    inflightMessages: operations_aggregate(\n      where: { is_inflight: { is_inflight: { _eq: true } } }\n    ) {\n      aggregate {\n        count\n      }\n    }\n    confirmedMessages: operation_count_agent_address_aggregate {\n      aggregate {\n        sum {\n          msg_count\n        }\n      }\n    }\n  }\n']
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(
  source: '\n  query getAgentsByFilters(\n    $where: agent_bool_exp = {}\n    $order_by: [agent_order_by!] = {}\n    $limit: Int\n    $offset: Int\n    $delegatorAddress: String = ""\n  ) {\n    agent(where: $where, order_by: $order_by, offset: $offset, limit: $limit) {\n      agent_protocol_supports {\n        protocol_id\n        id\n        created_at\n        agent_address\n        removed\n        transmitter\n        success_message_count {\n          msg_count\n        }\n        protocol {\n          id\n          protocol_id\n          protocol_executors {\n            chain_id\n          }\n        }\n      }\n      id\n      agent_address\n      operations_count {\n        msg_count\n      }\n      operation_count_total {\n        msg_count\n      }\n      agentInfoData: agent_info {\n        active_round_stake\n        address\n        personal_stake\n        relatime_stake\n        id\n        fee\n        unclaimed_rewards\n        deligatedSum: agent_info_delegators_aggregate {\n          aggregate {\n            sum {\n              stake\n            }\n          }\n        }\n        currentDelegated: agent_info_delegators (where: {address: {_eq: $delegatorAddress }}) {\n          id\n          stake\n          address\n      }\n      }\n      banned\n      created_at\n      paused\n      reward_address\n      agent_name {\n        name\n      }\n    }\n  }\n'
): (typeof documents)['\n  query getAgentsByFilters(\n    $where: agent_bool_exp = {}\n    $order_by: [agent_order_by!] = {}\n    $limit: Int\n    $offset: Int\n    $delegatorAddress: String = ""\n  ) {\n    agent(where: $where, order_by: $order_by, offset: $offset, limit: $limit) {\n      agent_protocol_supports {\n        protocol_id\n        id\n        created_at\n        agent_address\n        removed\n        transmitter\n        success_message_count {\n          msg_count\n        }\n        protocol {\n          id\n          protocol_id\n          protocol_executors {\n            chain_id\n          }\n        }\n      }\n      id\n      agent_address\n      operations_count {\n        msg_count\n      }\n      operation_count_total {\n        msg_count\n      }\n      agentInfoData: agent_info {\n        active_round_stake\n        address\n        personal_stake\n        relatime_stake\n        id\n        fee\n        unclaimed_rewards\n        deligatedSum: agent_info_delegators_aggregate {\n          aggregate {\n            sum {\n              stake\n            }\n          }\n        }\n        currentDelegated: agent_info_delegators (where: {address: {_eq: $delegatorAddress }}) {\n          id\n          stake\n          address\n      }\n      }\n      banned\n      created_at\n      paused\n      reward_address\n      agent_name {\n        name\n      }\n    }\n  }\n']
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(
  source: '\n  query getAgentsByAddressAndAgentAddress(\n    $address: String\n    $agentAddress: String\n  ) {\n    agent_info_delegator(\n      where: {\n        _and: { address: { _eq: $address } }\n        agent_info: { address: { _eq: $agentAddress } }\n      }\n    ) {\n      id\n      stake\n      unclaimed_rewards\n    }\n  }\n'
): (typeof documents)['\n  query getAgentsByAddressAndAgentAddress(\n    $address: String\n    $agentAddress: String\n  ) {\n    agent_info_delegator(\n      where: {\n        _and: { address: { _eq: $address } }\n        agent_info: { address: { _eq: $agentAddress } }\n      }\n    ) {\n      id\n      stake\n      unclaimed_rewards\n    }\n  }\n']
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(
  source: 'query getAgentsDelegatedAmount($delegatorAddress: String = "") {\n    agent_info_delegator_aggregate(where: {address: {_eq: $delegatorAddress}}) {\n      aggregate {\n        sum {\n          stake\n        }\n      }\n    }\n}'
): (typeof documents)['query getAgentsDelegatedAmount($delegatorAddress: String = "") {\n    agent_info_delegator_aggregate(where: {address: {_eq: $delegatorAddress}}) {\n      aggregate {\n        sum {\n          stake\n        }\n      }\n    }\n}']
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(
  source: '\nquery getAgentsByAddress($address: String = "", $order_by: [agent_order_by!] = {}, $limit: Int, $offset: Int) {\n  agent(where: {agent_info: {agent_info_delegators: {address: {_eq: $address}}}}, order_by: $order_by, offset: $offset, limit: $limit) {\n    agent_protocol_supports {\n      protocol_id\n      id\n      created_at\n      agent_address\n      removed\n      transmitter\n      success_message_count {\n        msg_count\n      }\n      protocol {\n        id\n        protocol_id\n        protocol_executors {\n          chain_id\n        }\n      }\n    }\n    id\n    agent_address\n    operations_count {\n      msg_count\n    }\n    operation_count_total {\n      msg_count\n    }\n    agentInfoData: agent_info {\n      active_round_stake\n      address\n      personal_stake\n      relatime_stake\n      id\n      fee\n      deligatedSum: agent_info_delegators_aggregate {\n        aggregate {\n          sum {\n            stake\n          }\n        }\n      }\n      currentDelegated: agent_info_delegators (where: {address: {_eq: $address }}) {\n        id\n        stake\n        address\n      }\n    }\n    banned\n    created_at\n    paused\n    reward_address\n    agent_name {\n        name\n    }\n  }\n}\n'
): (typeof documents)['\nquery getAgentsByAddress($address: String = "", $order_by: [agent_order_by!] = {}, $limit: Int, $offset: Int) {\n  agent(where: {agent_info: {agent_info_delegators: {address: {_eq: $address}}}}, order_by: $order_by, offset: $offset, limit: $limit) {\n    agent_protocol_supports {\n      protocol_id\n      id\n      created_at\n      agent_address\n      removed\n      transmitter\n      success_message_count {\n        msg_count\n      }\n      protocol {\n        id\n        protocol_id\n        protocol_executors {\n          chain_id\n        }\n      }\n    }\n    id\n    agent_address\n    operations_count {\n      msg_count\n    }\n    operation_count_total {\n      msg_count\n    }\n    agentInfoData: agent_info {\n      active_round_stake\n      address\n      personal_stake\n      relatime_stake\n      id\n      fee\n      deligatedSum: agent_info_delegators_aggregate {\n        aggregate {\n          sum {\n            stake\n          }\n        }\n      }\n      currentDelegated: agent_info_delegators (where: {address: {_eq: $address }}) {\n        id\n        stake\n        address\n      }\n    }\n    banned\n    created_at\n    paused\n    reward_address\n    agent_name {\n        name\n    }\n  }\n}\n']
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(
  source: '\n  query GetFrontendConfig($id: Int!) {\n    frontend_configs_by_pk(id: $id) {\n      id\n      config\n    }\n  }\n'
): (typeof documents)['\n  query GetFrontendConfig($id: Int!) {\n    frontend_configs_by_pk(id: $id) {\n      id\n      config\n    }\n  }\n']
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(
  source: '\n  query AverageBlockTime {\n    averageBlockTime: average_block_time_per_hour(limit: 1, order_by: { height: desc }) {\n      averageTime: average_time\n    }\n  }\n'
): (typeof documents)['\n  query AverageBlockTime {\n    averageBlockTime: average_block_time_per_hour(limit: 1, order_by: { height: desc }) {\n      averageTime: average_time\n    }\n  }\n']
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(
  source: '\n  query LatestBlockHeightListener($offset: Int = 0) {\n    height: block(order_by: { height: desc }, limit: 1, offset: $offset) {\n      height\n    }\n  }\n'
): (typeof documents)['\n  query LatestBlockHeightListener($offset: Int = 0) {\n    height: block(order_by: { height: desc }, limit: 1, offset: $offset) {\n      height\n    }\n  }\n']
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(
  source: '\n  query Blocks($limit: Int = 50, $offset: Int = 0, $where: block_bool_exp = {}) {\n    blocks: block(limit: $limit, offset: $offset, order_by: { height: desc }, where: $where) {\n      height\n      txs: num_txs\n      hash\n      timestamp\n      validator {\n        validatorInfo: validator_info {\n          operatorAddress: operator_address\n          self_delegate_address\n        }\n        validatorDescriptions: validator_descriptions(limit: 1, order_by: { height: desc }) {\n          moniker\n          identity\n        }\n      }\n    }\n  }\n'
): (typeof documents)['\n  query Blocks($limit: Int = 50, $offset: Int = 0, $where: block_bool_exp = {}) {\n    blocks: block(limit: $limit, offset: $offset, order_by: { height: desc }, where: $where) {\n      height\n      txs: num_txs\n      hash\n      timestamp\n      validator {\n        validatorInfo: validator_info {\n          operatorAddress: operator_address\n          self_delegate_address\n        }\n        validatorDescriptions: validator_descriptions(limit: 1, order_by: { height: desc }) {\n          moniker\n          identity\n        }\n      }\n    }\n  }\n']
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(
  source: '\n  subscription BlocksListener(\n    $limit: Int = 50\n    $offset: Int = 0\n    $where: block_bool_exp = {}\n  ) {\n    blocks: block(limit: $limit, offset: $offset, order_by: { height: desc }, where: $where) {\n      height\n      txs: num_txs\n      hash\n      timestamp\n      validator {\n        validatorInfo: validator_info {\n          operatorAddress: operator_address\n          self_delegate_address\n        }\n        validatorDescriptions: validator_descriptions(limit: 1, order_by: { height: desc }) {\n          moniker\n          identity\n        }\n      }\n    }\n  }\n'
): (typeof documents)['\n  subscription BlocksListener(\n    $limit: Int = 50\n    $offset: Int = 0\n    $where: block_bool_exp = {}\n  ) {\n    blocks: block(limit: $limit, offset: $offset, order_by: { height: desc }, where: $where) {\n      height\n      txs: num_txs\n      hash\n      timestamp\n      validator {\n        validatorInfo: validator_info {\n          operatorAddress: operator_address\n          self_delegate_address\n        }\n        validatorDescriptions: validator_descriptions(limit: 1, order_by: { height: desc }) {\n          moniker\n          identity\n        }\n      }\n    }\n  }\n']
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(
  source: '\n  query GetTransactionsPerBlock($limit: Int, $offset: Int, $hash: String) {\n    block(where: { hash: { _eq: $hash } }) {\n      timestamp\n      transactions {\n        height\n        hash\n        memo\n        success\n        fee\n        gasUsed: gas_used\n        gasWanted: gas_wanted\n        messages\n        logs\n        __typename\n      }\n    }\n  }\n'
): (typeof documents)['\n  query GetTransactionsPerBlock($limit: Int, $offset: Int, $hash: String) {\n    block(where: { hash: { _eq: $hash } }) {\n      timestamp\n      transactions {\n        height\n        hash\n        memo\n        success\n        fee\n        gasUsed: gas_used\n        gasWanted: gas_wanted\n        messages\n        logs\n        __typename\n      }\n    }\n  }\n']
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(
  source: '\n  query GetBlocksByHash($hash: String) {\n    blocks: block(where: { hash: { _eq: $hash } }) {\n      height\n      txs: num_txs\n      hash\n      timestamp\n      validator {\n        validatorInfo: validator_info {\n          operatorAddress: operator_address\n          self_delegate_address\n        }\n        validatorDescriptions: validator_descriptions(limit: 1, order_by: { height: desc }) {\n          moniker\n          identity\n        }\n      }\n    }\n  }\n'
): (typeof documents)['\n  query GetBlocksByHash($hash: String) {\n    blocks: block(where: { hash: { _eq: $hash } }) {\n      height\n      txs: num_txs\n      hash\n      timestamp\n      validator {\n        validatorInfo: validator_info {\n          operatorAddress: operator_address\n          self_delegate_address\n        }\n        validatorDescriptions: validator_descriptions(limit: 1, order_by: { height: desc }) {\n          moniker\n          identity\n        }\n      }\n    }\n  }\n']
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(
  source: '\n  query GetTransactionStatus(\n    $txHash: String!\n    $destChainId: numeric!\n    $sourceChainId: numeric!\n  ) {\n    bridge(\n      arg1: { dst_chain_id: $destChainId, src_chain_id: $sourceChainId, tx_hash: $txHash }\n    ) {\n      address_from\n      created_at\n      failed\n      id\n      operation_one_hash\n      operation_one_tx_hash\n      operation_two_hash\n      operation_two_tx_hash\n      src_hash\n      step\n      updated_at\n    }\n  }\n'
): (typeof documents)['\n  query GetTransactionStatus(\n    $txHash: String!\n    $destChainId: numeric!\n    $sourceChainId: numeric!\n  ) {\n    bridge(\n      arg1: { dst_chain_id: $destChainId, src_chain_id: $sourceChainId, tx_hash: $txHash }\n    ) {\n      address_from\n      created_at\n      failed\n      id\n      operation_one_hash\n      operation_one_tx_hash\n      operation_two_hash\n      operation_two_tx_hash\n      src_hash\n      step\n      updated_at\n    }\n  }\n']
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(
  source: '\n  subscription BridgeOperationsListener($address:String!) {\n    common_bridge_operations(\n      where: {\n        _or: [\n          { sender: { _eq: $address } },\n          { recipient: { _eq: $address } },\n          { metadata: { _contains: { additional_account: $address } } }\n        ]\n      }\n      order_by: { created_at: desc }\n    ) {\n      amount\n      arrived_at\n      bridge_protocol\n      created_at\n      dst_chain_id\n      dst_tx_hash\n      metadata\n      id\n      sender\n      src_chain_id\n      src_tx_hash\n      status\n      token\n      updated_at\n      recipient\n    }\n  }\n'
): (typeof documents)['\n  subscription BridgeOperationsListener($address:String!) {\n    common_bridge_operations(\n      where: {\n        _or: [\n          { sender: { _eq: $address } },\n          { recipient: { _eq: $address } },\n          { metadata: { _contains: { additional_account: $address } } }\n        ]\n      }\n      order_by: { created_at: desc }\n    ) {\n      amount\n      arrived_at\n      bridge_protocol\n      created_at\n      dst_chain_id\n      dst_tx_hash\n      metadata\n      id\n      sender\n      src_chain_id\n      src_tx_hash\n      status\n      token\n      updated_at\n      recipient\n    }\n  }\n']
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(
  source: '\nquery GetBridgeOperationsByTxHas($address:String!) {\n    common_bridge_operations(\n      where: { src_tx_hash: { _eq: $address } }\n      order_by: { created_at: desc }\n    ) {\n      amount\n      arrived_at\n      bridge_protocol\n      created_at\n      dst_chain_id\n      dst_tx_hash\n      metadata\n      id\n      sender\n      src_chain_id\n      src_tx_hash\n      status\n      token\n      updated_at\n      recipient\n    }\n}'
): (typeof documents)['\nquery GetBridgeOperationsByTxHas($address:String!) {\n    common_bridge_operations(\n      where: { src_tx_hash: { _eq: $address } }\n      order_by: { created_at: desc }\n    ) {\n      amount\n      arrived_at\n      bridge_protocol\n      created_at\n      dst_chain_id\n      dst_tx_hash\n      metadata\n      id\n      sender\n      src_chain_id\n      src_tx_hash\n      status\n      token\n      updated_at\n      recipient\n    }\n}']
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(
  source: '\nquery GetBridgeOperationsBySender($address:String!) {\n    common_bridge_operations(\n        where: {\n            sender: { _eq: $address }\n        }\n    ) {\n      amount\n      arrived_at\n      bridge_protocol\n      created_at\n      dst_chain_id\n      dst_tx_hash\n      metadata\n      id\n      sender\n      src_chain_id\n      src_tx_hash\n      status\n      token\n      updated_at\n      recipient\n    }\n}'
): (typeof documents)['\nquery GetBridgeOperationsBySender($address:String!) {\n    common_bridge_operations(\n        where: {\n            sender: { _eq: $address }\n        }\n    ) {\n      amount\n      arrived_at\n      bridge_protocol\n      created_at\n      dst_chain_id\n      dst_tx_hash\n      metadata\n      id\n      sender\n      src_chain_id\n      src_tx_hash\n      status\n      token\n      updated_at\n      recipient\n    }\n}']
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(
  source: '\n  query GetBridgeOperationsCount($address:String!) {\n    common_bridge_operations_aggregate(where: { sender:{_eq:$address}}) {\n      aggregate {\n        count\n      }\n    }\n  }\n'
): (typeof documents)['\n  query GetBridgeOperationsCount($address:String!) {\n    common_bridge_operations_aggregate(where: { sender:{_eq:$address}}) {\n      aggregate {\n        count\n      }\n    }\n  }\n']
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(
  source: '\n  query GetOperationsByFilters(\n    $where: operations_bool_exp = { _and: {} }\n    $limit: Int\n    $offset: Int\n  ) {\n    operations(\n      where: $where\n      offset: $offset\n      limit: $limit\n      order_by: { created_at: desc }\n    ) {\n      src_tx_sender\n      src_tx_hash\n      src_chain_id\n      src_block_number\n      required_confirmations\n      protocol_id\n      protocol_address\n      params\n      nonce\n      in_order\n      id\n      hash\n      function_selector\n      dst_chain_id\n      destination_tx_hash\n      delivered\n      created_at\n      operation_proof {\n        operation_proof_transmitter_sigs_aggregate {\n          aggregate {\n            count\n          }\n        }\n      }\n    }\n  }\n'
): (typeof documents)['\n  query GetOperationsByFilters(\n    $where: operations_bool_exp = { _and: {} }\n    $limit: Int\n    $offset: Int\n  ) {\n    operations(\n      where: $where\n      offset: $offset\n      limit: $limit\n      order_by: { created_at: desc }\n    ) {\n      src_tx_sender\n      src_tx_hash\n      src_chain_id\n      src_block_number\n      required_confirmations\n      protocol_id\n      protocol_address\n      params\n      nonce\n      in_order\n      id\n      hash\n      function_selector\n      dst_chain_id\n      destination_tx_hash\n      delivered\n      created_at\n      operation_proof {\n        operation_proof_transmitter_sigs_aggregate {\n          aggregate {\n            count\n          }\n        }\n      }\n    }\n  }\n']
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(
  source: '\n  subscription MessagesListener(\n    $where: operations_bool_exp = { _and: {} }\n    $limit: Int\n    $offset: Int\n  ) {\n    operations(where: $where, offset: $offset, limit: $limit, order_by: { created_at: desc }) {\n      src_tx_sender\n      src_tx_hash\n      src_chain_id\n      src_block_number\n      required_confirmations\n      protocol_id\n      protocol_address\n      params\n      nonce\n      in_order\n      id\n      hash\n      function_selector\n      dst_chain_id\n      destination_tx_hash\n      delivered\n      created_at\n      operation_proof {\n        operation_proof_transmitter_sigs_aggregate {\n          aggregate {\n            count\n          }\n        }\n      }\n    }\n  }\n'
): (typeof documents)['\n  subscription MessagesListener(\n    $where: operations_bool_exp = { _and: {} }\n    $limit: Int\n    $offset: Int\n  ) {\n    operations(where: $where, offset: $offset, limit: $limit, order_by: { created_at: desc }) {\n      src_tx_sender\n      src_tx_hash\n      src_chain_id\n      src_block_number\n      required_confirmations\n      protocol_id\n      protocol_address\n      params\n      nonce\n      in_order\n      id\n      hash\n      function_selector\n      dst_chain_id\n      destination_tx_hash\n      delivered\n      created_at\n      operation_proof {\n        operation_proof_transmitter_sigs_aggregate {\n          aggregate {\n            count\n          }\n        }\n      }\n    }\n  }\n']
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(
  source: '\n  query Params {\n    staking_params {\n      params\n    }\n\n    slashing_params {\n      params\n    }\n\n    gov_params {\n      params\n    }\n\n    distribution_params {\n      params\n    }\n  }\n'
): (typeof documents)['\n  query Params {\n    staking_params {\n      params\n    }\n\n    slashing_params {\n      params\n    }\n\n    gov_params {\n      params\n    }\n\n    distribution_params {\n      params\n    }\n  }\n']
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(
  source: '\n  query GetProtocolsByFilters(\n    $where: protocol_bool_exp = { _and: {} }\n    $order_by: [protocol_order_by!] = {}\n    $limit: Int\n    $offset: Int\n  ) {\n    protocol(where: $where, order_by: $order_by, offset: $offset, limit: $limit) {\n      consensus_target_rate\n      created_at\n      data_bet_amount\n      data_bet_reward\n      first_data_bet_reward\n      first_msg_bet_reward\n      id\n      max_transmitters\n      min_delegate_amount\n      min_personal_amount\n      msg_bet_amount\n      msg_bet_reward\n      owner\n      protocol_id\n      operations_count {\n        count\n      }\n      protocol_transmitters {\n        transmitter\n      }\n      protocol_executors {\n        chain_id\n      }\n      protocol_transmitters_aggregate {\n        aggregate {\n          count(columns: id)\n        }\n      }\n    }\n  }\n'
): (typeof documents)['\n  query GetProtocolsByFilters(\n    $where: protocol_bool_exp = { _and: {} }\n    $order_by: [protocol_order_by!] = {}\n    $limit: Int\n    $offset: Int\n  ) {\n    protocol(where: $where, order_by: $order_by, offset: $offset, limit: $limit) {\n      consensus_target_rate\n      created_at\n      data_bet_amount\n      data_bet_reward\n      first_data_bet_reward\n      first_msg_bet_reward\n      id\n      max_transmitters\n      min_delegate_amount\n      min_personal_amount\n      msg_bet_amount\n      msg_bet_reward\n      owner\n      protocol_id\n      operations_count {\n        count\n      }\n      protocol_transmitters {\n        transmitter\n      }\n      protocol_executors {\n        chain_id\n      }\n      protocol_transmitters_aggregate {\n        aggregate {\n          count(columns: id)\n        }\n      }\n    }\n  }\n']
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(
  source: '\n  query getProtocolById($id: String) {\n    protocol(where: { protocol_id: { _eq: $id } }) {\n      operations(limit: 1, order_by: { created_at: desc }) {\n        required_confirmations\n      }\n      consensus_target_rate\n      created_at\n      data_bet_amount\n      data_bet_reward\n      balance\n      first_data_bet_reward\n      first_msg_bet_reward\n      id\n      protocol_proposers {\n        chain_id\n      }\n      max_transmitters\n      min_delegate_amount\n      min_personal_amount\n      msg_bet_amount\n      msg_bet_reward\n      owner\n      protocol_id\n      operations_count {\n        count\n      }\n      protocol_transmitters {\n        transmitter\n      }\n      protocol_executors {\n        chain_id\n      }\n      protocol_transmitters_aggregate {\n        aggregate {\n          count(columns: id)\n        }\n      }\n      protocol_proposers_aggregate {\n        aggregate {\n          count\n        }\n      }\n      protocol_executors_aggregate {\n        aggregate {\n          count\n        }\n      }\n    }\n  }\n'
): (typeof documents)['\n  query getProtocolById($id: String) {\n    protocol(where: { protocol_id: { _eq: $id } }) {\n      operations(limit: 1, order_by: { created_at: desc }) {\n        required_confirmations\n      }\n      consensus_target_rate\n      created_at\n      data_bet_amount\n      data_bet_reward\n      balance\n      first_data_bet_reward\n      first_msg_bet_reward\n      id\n      protocol_proposers {\n        chain_id\n      }\n      max_transmitters\n      min_delegate_amount\n      min_personal_amount\n      msg_bet_amount\n      msg_bet_reward\n      owner\n      protocol_id\n      operations_count {\n        count\n      }\n      protocol_transmitters {\n        transmitter\n      }\n      protocol_executors {\n        chain_id\n      }\n      protocol_transmitters_aggregate {\n        aggregate {\n          count(columns: id)\n        }\n      }\n      protocol_proposers_aggregate {\n        aggregate {\n          count\n        }\n      }\n      protocol_executors_aggregate {\n        aggregate {\n          count\n        }\n      }\n    }\n  }\n']
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(
  source: '\n  query Tokenomics {\n    stakingParams: staking_params(limit: 1) {\n      params\n    }\n    stakingPool: staking_pool(order_by: { height: desc }, limit: 1) {\n      bonded: bonded_tokens\n      unbonded: not_bonded_tokens\n    }\n    supply: supply(order_by: { height: desc }, limit: 1) {\n      coins\n    }\n  }\n'
): (typeof documents)['\n  query Tokenomics {\n    stakingParams: staking_params(limit: 1) {\n      params\n    }\n    stakingPool: staking_pool(order_by: { height: desc }, limit: 1) {\n      bonded: bonded_tokens\n      unbonded: not_bonded_tokens\n    }\n    supply: supply(order_by: { height: desc }, limit: 1) {\n      coins\n    }\n  }\n']
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(
  source: '\n  query Transactions($limit: Int, $offset: Int, $where: transaction_bool_exp = {}) {\n    transactions: transaction(\n      limit: $limit\n      offset: $offset\n      order_by: { height: desc }\n      where: $where\n    ) {\n      height\n      hash\n      memo\n      success\n      fee\n      gasUsed: gas_used\n      gasWanted: gas_wanted\n      block {\n        timestamp\n        __typename\n      }\n      messages\n      logs\n      __typename\n    }\n  }\n'
): (typeof documents)['\n  query Transactions($limit: Int, $offset: Int, $where: transaction_bool_exp = {}) {\n    transactions: transaction(\n      limit: $limit\n      offset: $offset\n      order_by: { height: desc }\n      where: $where\n    ) {\n      height\n      hash\n      memo\n      success\n      fee\n      gasUsed: gas_used\n      gasWanted: gas_wanted\n      block {\n        timestamp\n        __typename\n      }\n      messages\n      logs\n      __typename\n    }\n  }\n']
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(
  source: '\n  query Transaction($ethHash: String) {\n    transaction(where: { eth_hash: { _eq: $ethHash } }) {\n      height\n      hash\n      memo\n      success\n      fee\n      gasUsed: gas_used\n      gasWanted: gas_wanted\n      block {\n        timestamp\n        __typename\n      }\n      messages\n      logs\n      __typename\n    }\n  }\n'
): (typeof documents)['\n  query Transaction($ethHash: String) {\n    transaction(where: { eth_hash: { _eq: $ethHash } }) {\n      height\n      hash\n      memo\n      success\n      fee\n      gasUsed: gas_used\n      gasWanted: gas_wanted\n      block {\n        timestamp\n        __typename\n      }\n      messages\n      logs\n      __typename\n    }\n  }\n']
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(
  source: '\n  subscription TransactionsListener(\n    $limit: Int = 7\n    $offset: Int = 0\n    $where: transaction_bool_exp = {}\n  ) {\n    transactions: transaction(\n      limit: $limit\n      offset: $offset\n      order_by: { height: desc }\n      where: $where\n    ) {\n      height\n      hash\n      memo\n      success\n      fee\n      gasUsed: gas_used\n      gasWanted: gas_wanted\n      block {\n        timestamp\n        __typename\n      }\n      messages\n      logs\n      __typename\n    }\n  }\n'
): (typeof documents)['\n  subscription TransactionsListener(\n    $limit: Int = 7\n    $offset: Int = 0\n    $where: transaction_bool_exp = {}\n  ) {\n    transactions: transaction(\n      limit: $limit\n      offset: $offset\n      order_by: { height: desc }\n      where: $where\n    ) {\n      height\n      hash\n      memo\n      success\n      fee\n      gasUsed: gas_used\n      gasWanted: gas_wanted\n      block {\n        timestamp\n        __typename\n      }\n      messages\n      logs\n      __typename\n    }\n  }\n']
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(
  source: '\n  subscription priceChartsSubscription ($where: price_charts_bool_exp = {}) {\n    price_charts(where: $where) {\n      asset_id\n      category_id\n      chart\n      data_key\n      time\n      value\n      assets_info {\n        icon_url\n        category {\n          name\n        }\n        float_digits\n        decimals\n      }\n    }\n  }\n'
): (typeof documents)['\n  subscription priceChartsSubscription ($where: price_charts_bool_exp = {}) {\n    price_charts(where: $where) {\n      asset_id\n      category_id\n      chart\n      data_key\n      time\n      value\n      assets_info {\n        icon_url\n        category {\n          name\n        }\n        float_digits\n        decimals\n      }\n    }\n  }\n']
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(
  source: '\n  query MarketCategories {\n  category {\n    id\n    name\n  }\n}\n'
): (typeof documents)['\n  query MarketCategories {\n  category {\n    id\n    name\n  }\n}\n']
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(
  source: '\n  query MarketUsdRate {\n  usd_rate {\n    rate\n    currency\n  }\n}\n'
): (typeof documents)['\n  query MarketUsdRate {\n  usd_rate {\n    rate\n    currency\n  }\n}\n']
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(
  source: '\n  query TotalValueSecured {\n    total_value_secured(limit: 1, order_by: {time:desc}) {\n      value\n    }\n  }\n'
): (typeof documents)['\n  query TotalValueSecured {\n    total_value_secured(limit: 1, order_by: {time:desc}) {\n      value\n    }\n  }\n']
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(
  source: '\n  query ActiveValidatorCount {\n    activeTotal: validator_status_aggregate(where: { status: { _eq: 3 } }) {\n      aggregate {\n        count\n      }\n    }\n    inactiveTotal: validator_status_aggregate(where: { status: { _neq: 3 } }) {\n      aggregate {\n        count\n      }\n    }\n    total: validator_status_aggregate {\n      aggregate {\n        count\n      }\n    }\n  }\n'
): (typeof documents)['\n  query ActiveValidatorCount {\n    activeTotal: validator_status_aggregate(where: { status: { _eq: 3 } }) {\n      aggregate {\n        count\n      }\n    }\n    inactiveTotal: validator_status_aggregate(where: { status: { _neq: 3 } }) {\n      aggregate {\n        count\n      }\n    }\n    total: validator_status_aggregate {\n      aggregate {\n        count\n      }\n    }\n  }\n']
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(
  source: '\n  query getValidators($where: validator_bool_exp = {}) {\n    stakingPool: staking_pool(limit: 1, order_by: { height: desc }) {\n      bondedTokens: bonded_tokens\n    }\n    validator(where: $where, order_by: { real_voting_power: { voting_power: desc } }) {\n      validatorStatuses: validator_statuses(order_by: { height: desc }, limit: 1) {\n        status\n        jailed\n        height\n      }\n      validatorDescriptions: validator_descriptions {\n        moniker\n        avatar_url\n      }\n      validatorSigningInfos: validator_signing_infos(order_by: { height: desc }, limit: 1) {\n        missedBlocksCounter: missed_blocks_counter\n        tombstoned\n        startHeight: start_height\n      }\n      validatorInfo: validator_info {\n        operatorAddress: operator_address\n        selfDelegateAddress: self_delegate_address\n      }\n      validatorVotingPowers: validator_voting_powers(\n        offset: 0\n        limit: 1\n        order_by: { height: desc }\n      ) {\n        votingPower: voting_power\n      }\n      validatorCommissions: validator_commissions(order_by: { height: desc }, limit: 1) {\n        commission\n      }\n      validatorSigningInfos: validator_signing_infos(order_by: { height: desc }, limit: 1) {\n        missedBlocksCounter: missed_blocks_counter\n      }\n      validatorDelegations: validator_delegations {\n        total_delegations\n        self_delegation\n      }\n    }\n    slashingParams: slashing_params(order_by: { height: desc }, limit: 1) {\n      params\n    }\n    validatorStats: validator_stats {\n      apr\n      validator {\n        validator_info {\n          operator_address\n        }\n      }\n    }\n  }\n'
): (typeof documents)['\n  query getValidators($where: validator_bool_exp = {}) {\n    stakingPool: staking_pool(limit: 1, order_by: { height: desc }) {\n      bondedTokens: bonded_tokens\n    }\n    validator(where: $where, order_by: { real_voting_power: { voting_power: desc } }) {\n      validatorStatuses: validator_statuses(order_by: { height: desc }, limit: 1) {\n        status\n        jailed\n        height\n      }\n      validatorDescriptions: validator_descriptions {\n        moniker\n        avatar_url\n      }\n      validatorSigningInfos: validator_signing_infos(order_by: { height: desc }, limit: 1) {\n        missedBlocksCounter: missed_blocks_counter\n        tombstoned\n        startHeight: start_height\n      }\n      validatorInfo: validator_info {\n        operatorAddress: operator_address\n        selfDelegateAddress: self_delegate_address\n      }\n      validatorVotingPowers: validator_voting_powers(\n        offset: 0\n        limit: 1\n        order_by: { height: desc }\n      ) {\n        votingPower: voting_power\n      }\n      validatorCommissions: validator_commissions(order_by: { height: desc }, limit: 1) {\n        commission\n      }\n      validatorSigningInfos: validator_signing_infos(order_by: { height: desc }, limit: 1) {\n        missedBlocksCounter: missed_blocks_counter\n      }\n      validatorDelegations: validator_delegations {\n        total_delegations\n        self_delegation\n      }\n    }\n    slashingParams: slashing_params(order_by: { height: desc }, limit: 1) {\n      params\n    }\n    validatorStats: validator_stats {\n      apr\n      validator {\n        validator_info {\n          operator_address\n        }\n      }\n    }\n  }\n']
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(
  source: '\n  query GetValidatorByOperatorAddress($operatorAddress: String!) {\n    validatorInfo: validator_info(where: { operator_address: { _eq: $operatorAddress } }) {\n      validator {\n        validatorStatuses: validator_statuses(order_by: { height: desc }, limit: 1) {\n          status\n          jailed\n          height\n        }\n        validatorDescriptions: validator_descriptions {\n          moniker\n          avatar_url\n        }\n        validatorSigningInfos: validator_signing_infos(order_by: { height: desc }, limit: 1) {\n          missedBlocksCounter: missed_blocks_counter\n          tombstoned\n        }\n        validatorInfo: validator_info {\n          operatorAddress: operator_address\n          selfDelegateAddress: self_delegate_address\n        }\n        validatorVotingPowers: validator_voting_powers(\n          offset: 0\n          limit: 1\n          order_by: { height: desc }\n        ) {\n          votingPower: voting_power\n        }\n        validatorCommissions: validator_commissions(order_by: { height: desc }, limit: 1) {\n          commission\n        }\n        validatorSigningInfos: validator_signing_infos(order_by: { height: desc }, limit: 1) {\n          missedBlocksCounter: missed_blocks_counter\n        }\n      }\n    }\n  }\n'
): (typeof documents)['\n  query GetValidatorByOperatorAddress($operatorAddress: String!) {\n    validatorInfo: validator_info(where: { operator_address: { _eq: $operatorAddress } }) {\n      validator {\n        validatorStatuses: validator_statuses(order_by: { height: desc }, limit: 1) {\n          status\n          jailed\n          height\n        }\n        validatorDescriptions: validator_descriptions {\n          moniker\n          avatar_url\n        }\n        validatorSigningInfos: validator_signing_infos(order_by: { height: desc }, limit: 1) {\n          missedBlocksCounter: missed_blocks_counter\n          tombstoned\n        }\n        validatorInfo: validator_info {\n          operatorAddress: operator_address\n          selfDelegateAddress: self_delegate_address\n        }\n        validatorVotingPowers: validator_voting_powers(\n          offset: 0\n          limit: 1\n          order_by: { height: desc }\n        ) {\n          votingPower: voting_power\n        }\n        validatorCommissions: validator_commissions(order_by: { height: desc }, limit: 1) {\n          commission\n        }\n        validatorSigningInfos: validator_signing_infos(order_by: { height: desc }, limit: 1) {\n          missedBlocksCounter: missed_blocks_counter\n        }\n      }\n    }\n  }\n']

export function gql(source: string) {
  return (documents as any)[source] ?? {}
}

export type DocumentType<TDocumentNode extends DocumentNode<any, any>> =
  TDocumentNode extends DocumentNode<infer TType, any> ? TType : never
